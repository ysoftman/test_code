// author : ysoftman
// encoding : utf-8
// title : json 테스트
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
)

const strJSON = `
{
"name":"ysoftman", 
"age":20,
"history" : {"date":"20141010", "action":"dosomething"},
"source" : "<script>hello world</script>"
}
`

// JSONDataInner 데이터 타입
type JSONDataInner struct {
	Date   string
	Action string
}

type ExtraStruct struct {
	val int
}

// JSONData 데이터 타입
type JSONData struct {

	//Name	string	// json 키값과 같은 이름의 변수를 선언하던가
	UserName string `json:"name"` // json key tag 를 명시하던가, marshal시 name 으로 필드명 사용
	Age      int
	History  JSONDataInner
	Source   string       `json:"source"`
	Extra1   int          `json:"zzz,omitempty"` // 값이 비워져 있으면 marshal에서 제외
	Extra2   *ExtraStruct `json:",omitempty"`    // struct 에 omitempty 를 적용하려면 포인터여야 한다.
	Extra3   string       `json:"-"`             // "-" 로 명시하면 marshal 수행시 무시(제외)된다.
}

// JSONFile : AutoGenerated by https://mholt.github.io/json-to-go/ÎÎ
type JSONFile struct {
	Key1 string `json:"key1"`
	Key2 string `json:"key2"`
	Key3 string `json:"key3"`
}

func main() {
	fmt.Println("json test...")

	marshalJSON()
	unmarshalJSON()
	unmarshalJSONFile()
	encodeJSON()
}

func marshalJSON() {
	// bool 형 json 만들기
	jsonBool, _ := json.Marshal(true)
	fmt.Println("jsonBool = ", string(jsonBool))

	// int 형 json 만들기
	jsonInt, _ := json.Marshal(123)
	fmt.Println("jsonInt = ", string(jsonInt))

	// string 형 json 만들기
	jsonString, _ := json.Marshal("<script>ysoftman</script>")
	fmt.Println("jsonString = ", string(jsonString))

	// 배열 json 만들기
	array := []string{"red", "green", "blue"}
	jsonArray, _ := json.Marshal(array)
	fmt.Println("jsonArray = ", string(jsonArray))

	// 맵 json 만들기
	obj := map[string]string{"name1": "ysoftman", "name2": "hong gil-dong"}
	jsonObj, _ := json.Marshal(obj)
	fmt.Println("jsonObj = ", string(jsonObj))

	// struct json 만들기
	JSONData := &JSONData{}
	// JSONData.Extra2 = &ExtraStruct{val: 1} // Extra2 는 omitempty 로 설정되어 값 설정이 없으면 빠진다.
	jsonData, _ := json.Marshal(JSONData)
	fmt.Println("JSONDATA", string(jsonData))
}

func unmarshalJSON() {
	// json 파싱
	JSONData := &JSONData{}
	json.Unmarshal([]byte(strJSON), &JSONData)
	fmt.Println("strJSON = ", JSONData)
	fmt.Println("strJSON = ", JSONData.UserName)
	fmt.Println("strJSON = ", JSONData.Age)
	fmt.Println("strJSON = ", JSONData.History.Date)
	fmt.Println("strJSON = ", JSONData.History.Action)

	// HTMLEscape (json 데이터를 HTML <scritp>내에서 사용할때 사용)
	dst := new(bytes.Buffer)
	json.HTMLEscape(dst, []byte(strJSON))
	fmt.Println(dst.String())

	bytesbuffer := new(bytes.Buffer)
	encoder := json.NewEncoder(bytesbuffer)
	// html escape 없이 인코딩
	encoder.SetEscapeHTML(false)
	encoder.SetIndent("", "  ")
	encoder.Encode(JSONData)
	fmt.Println(bytesbuffer.String())
}

func unmarshalJSONFile() {
	// json file 로드
	file, err := ioutil.ReadFile("./json_data.json")
	if err != nil {
		log.Fatal("can't read file ...", err.Error())
	}
	var jSONfile JSONFile
	json.Unmarshal(file, &jSONfile)
	fmt.Println(jSONfile)
	fmt.Println(jSONfile.Key1)
	fmt.Println(jSONfile.Key2)
	fmt.Println(jSONfile.Key3)
}

func encodeJSON() {
	// Marshal 은 기본적으로 특수문자들이 유니코드 escape 으로 인코딩된다.
	// json/encoding.go Marshal() 주석 중 발췌
	// String values encode as JSON strings coerced to valid UTF-8,
	// replacing invalid bytes with the Unicode replacement rune.
	// The angle brackets "<" and ">" are escaped to "\u003c" and "\u003e"
	// to keep some browsers from misinterpreting JSON output as HTML.
	// Ampersand "&" is also escaped to "\u0026" for the same reason.
	// This escaping can be disabled using an Encoder with DisableHTMLEscaping.
	// <, >, &  ====> \u003c, \u003e, \u0026
	// Marshal 대신 encoder 를 사용하여 escape 없이 인코딩할 수 있다.
	bytesbuffer1 := new(bytes.Buffer)
	encoder := json.NewEncoder(bytesbuffer1)
	// html escape 없이 인코딩
	encoder.SetEscapeHTML(false)
	encoder.SetIndent("", "  ")
	encoder.Encode("<script>ysoftman</script>")
	fmt.Println("jsonString = ", bytesbuffer1.String())
}
