# Configuration for Vector's Ingress.
ingress:
  # ingress.enabled -- If true, create and use an Ingress resource.
  enabled: true
  # ingress.className -- Specify the [ingressClassName](https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress),
  # requires Kubernetes >= 1.18
  className: "nginx"
  # ingress.annotations -- Set annotations on the Ingress.
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # ingress.hosts -- Configure the hosts and paths for the Ingress.
  hosts:
   - host: ysoftman.vector
     paths:
       - path: /
         pathType: ImplementationSpecific
         # Specify the port name or number on the Service
         # Using name requires Kubernetes >=1.19
         port:
           name: "vector"
           number: 8686
  # ingress.tls -- Configure TLS for the Ingress.
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# role -- [Role](https://vector.dev/docs/setup/deployment/roles/) for this Vector instance, valid options are:
# "Agent", "Aggregator", and "Stateless-Aggregator".
# Each role is created with the following workloads:
# Agent = DaemonSet
# Aggregator = StatefulSet
# Stateless-Aggregator = Deployment
role: "Agent"

customConfig:
  data_dir: /vector-data-dir
  api:
    enabled: true
    address: 0.0.0.0:8686
    playground: true
  sources:
    # Pod의 File Log를 읽어옵니다.
    # 참고: https://vector.dev/docs/reference/configuration/sources/kubernetes_logs/
    container_logs:
      type: "kubernetes_logs"
      include_paths_glob_patterns:
      - "/var/log/pods/*.log"
      glob_minimum_cooldown_ms: 8000
      max_line_bytes: 204800
  transforms:
    # 로그 데이터를 재매핑(Remap)하는 Transform
    remap_log_fields:
      type: "remap"
      inputs:
        - "container_logs" # 위에서 정의한 Source의 출력
      source: |
        # ⚠️ Vector Remap Language (VRL) 사용
        # 원본 로그 데이터의 필드를 간결하게 재구성합니다.

        # 1. 로그 레벨(level) 필드가 없으면 'info'로 기본 설정합니다.
        .level = if !exists(.level) { "info" } else { .level }

        # 2. 타임스탬프를 ISO 8601 형식으로 변환하여 새 필드에 저장합니다.
        .simple_time = format_timestamp!(.timestamp, format: "iso8601")

        # 3. 원본 로그 메시지에서 불필요한 공백/개행을 제거합니다.
        .simple_message = strip_whitespace!(.message)

        # 4. 최종적으로 출력할 필드만 남깁니다. (선택 사항: . = {})
        # . = {} # 모든 필드를 제거하고 아래 필드만 다시 추가할 경우 사용

        # 5. 최종 메시지를 생성합니다.
        level_str = to_string(.level) ?? "UNKNOWN"
        level_up = upcase(level_str) ?? "UNKNOWN"

        simple_time = .simple_time ?? "-"
        pod_name = .kubernetes.pod_name ?? "-"
        trimmed = .trimmed_message ?? ""

        .final_message = "[ " + simple_time + " | " + level_up + " | " + pod_name + " ] " + trimmed

  sinks:
    # 표준 출력(stdout)으로 데이터를 내보내는 Sink
    stdout_sink:
      type: "console"
      inputs:
        - "remap_log_fields" # Remap Transform의 출력
      encoding:
        # 메시지를 한 줄의 텍스트로 깔끔하게 출력하도록 설정
        codec: "text"
        # 출력할 메시지 필드를 지정합니다.
        field: "final_message"
